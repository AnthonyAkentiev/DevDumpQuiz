<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>questions</key>
	<array>
		<dict>
			<key>Comment</key>
			<string>for statement</string>
			<key>Id</key>
			<string>510</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1+2</string>
			<key>answers</key>
			<array>
				<string>First</string>
				<string>Second</string>
				<string>Third</string>
				<string>Fourth</string>
			</array>
			<key>a</key>
			<string>&lt;p&gt;The first and the second statements are correct.&lt;/p&gt;
&lt;p&gt;The for statement provides a compact way to iterate over a range of values. Programmers often refer to it as the &quot;for loop&quot; because of the way in which it repeatedly loops until a particular condition is satisfied. The general form of the for statement can be expressed as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
for (initialization; termination;
     increment) {
    statement(s)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The for statement also has another form designed for iteration through Collections and arrays. This form is sometimes referred to as the enhanced for statement, and can be used to make your loops more compact and easy to read, e.g.: for (int item : numbers)&lt;/p&gt;
 
&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html&quot;&gt;docs.oracle page&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;Which of these statements are correct?&lt;/h2&gt;
 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
int[] arr = {1, 2, 3};

//first        
for (int i = 0; i &lt; arr.length; ++i) { }

//second
for (int i: arr) { }

//third
foreach (int i: arr) { }

//fourth
for each (int i: arr) { }
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>main signature</string>
			<key>Id</key>
			<string>511</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>public static void main(String[] args)</string>
				<string>public static int main(String[] args)</string>
				<string>public int main(String[] args)</string>
				<string>public void main(String[] args)</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Main method signature&lt;/h2&gt;
&lt;p&gt;public static void main(String[] args)&lt;/p&gt;
&lt;p&gt;public keyword is an access modifier which represents visibility, it means it is visible to all&lt;/p&gt;
&lt;p&gt;static is a keyword, if we declare any method as static, it is known as static method. The core advantage of static method is that there is no need to create object to invoke the static method. The main method is executed by the JVM, so it doesn&apos;t require to create object to invoke the main method.&lt;/p&gt;
&lt;p&gt;void is the return type of the method, it means it doesn&apos;t return any value.&lt;/p&gt;
&lt;p&gt;main represents startup of the program.&lt;/p&gt;
&lt;/p&gt;String[] args is used for command line argument.&lt;/p&gt;
 
&lt;a href=&quot;http://www.javatpoint.com/simple-program-of-java&quot;&gt;javatpoint page&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What is the correct main() method signature?&lt;/h2&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>string comparison</string>
			<key>Id</key>
			<string>512</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>true false</string>
				<string>false true</string>
				<string>true true</string>
				<string>false false</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;String comparison&lt;/h2&gt;&lt;p&gt;a1 and b1 have the same value but they are not the same object and &quot;==&quot; tests for reference equality. So the first boolean value is false.&lt;/p&gt;
&lt;p&gt;a2 and b2 are literals which are interned by the compiler and thus refer to the same object. That is why the second boolean value is true.&lt;/p&gt;
 
&lt;a href=&quot;http://stackoverflow.com/a/513839/1389883&quot;&gt;Stackoverflow answer&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What will be the output of this program?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
String a1 = new String(&quot;abc&quot;);
String b1 = new String(&quot;abc&quot;);
        
String a2 = &quot;abc&quot;;
String b2 = &quot;abc&quot;;
        
System.out.println((a1==b1) + &quot; &quot; + (a2==b2));
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>outer</string>
			<key>Id</key>
			<string>513</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>4</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>this.p = p;</string>
				<string>p = p;</string>
				<string>Outer.this.p = p;</string>
				<string>Outer.p = p;</string>
			</array>
			<key>a</key>
			<string>&lt;p&gt;The first and the second answers are incorrect because they have no effect. The simply set the value of a parametr p to it&apos;s value.&lt;/p&gt;
&lt;p&gt;The fourth answer is incorrect because variable p is non-static and it cannot be referenced from a static context (line 5).&lt;/p&gt;
&lt;p&gt;The third answer is correct because it uses &quot;this&quot; keyword, &quot;this&quot; is a reference to the current object.&lt;/p&gt;
 
&lt;a href=&quot;http://stackoverflow.com/q/12346343/1389883&quot;&gt;Stackoverflow post&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;How do you set value of a variable p of class &quot;Outer&quot; on the line 5?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
class Outer {
    int p;
    class Inner {
        void setP(int p) {
            //line 5
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>primitive types</string>
			<key>Id</key>
			<string>514</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>1</string>
				<string>2</string>
				<string>3</string>
				<string>4</string>
			</array>
			<key>a</key>
			<string>&lt;p&gt;Integers are so-called primitive types. Passing the integer copies its value and assigns it to the parameter too. But that value is not a reference to the actual data, but is the data itself. So changes to the paramter in the function will affect the parameter (b), but not the argument passed in the calling function (a).&lt;/p&gt;

 
&lt;a href=&quot;http://stackoverflow.com/a/489921/1389883&quot;&gt;Stackoverflow post&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What will be the output of this program?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
public class HelloWorld {  
	static void f(int b) {
    	b += 1;
	}

	public static void main(String []args) {
        int a = 1;
        f(a);
        System.out.println(a);
     }
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>default parameters</string>
			<key>Id</key>
			<string>515</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>Yes</string>
				<string>No</string>
				<string>Yes, for primitives only</string>
				<string>Yes, for classes only</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Default parameters&lt;/h2&gt;
&lt;p&gt;No, Java handles it with overloading instead of default parameters.&lt;/p&gt;
&lt;p&gt;For constructors, See Effective Java: Programming Language Guide&apos;s Item 1 tip (Consider static factory methods instead of constructors) if the overloading is getting complicated. For other methods, renaming some cases or using a parameter object can help. This is when you have enough complexity that differentiating is difficult. A definite case is where you have to differentiate using the order of parameters, not just number and type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
public MyParameterizedFunction(String param1, int param2)
{
    this(param1, param2, false);
}

public MyParameterizedFunction(String param1, int param2, boolean param3)
{
    //use all three parameters here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&quot;http://stackoverflow.com/a/997529/1389883&quot;&gt;Stackoverflow post&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;Does Java support default parameter values?&lt;/h2&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>string 1</string>
			<key>Id</key>
			<string>516</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>4</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>1</string>
				<string>2</string>
				<string>12</string>
				<string>21</string>
			</array>
			<key>a</key>
			<string>&lt;p&gt;The Java programming language supports overloading methods, and Java can distinguish between methods with different method signatures. This means that methods within a class can have the same name if they have different parameter lists.&lt;/p&gt;
&lt;p&gt;When you call method with super class reference, no matters if object is of sub class it will go to the super class. If you call it with sub class reference, it always will go to the sub class.&lt;/p&gt;

 
&lt;a href=&quot;http://stackoverflow.com/a/23077908/1389883&quot;&gt;Stackoverflow answer&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What will be the output of this program?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
public class Main {
    public static void a(String o) {
        System.out.println(&quot;1&quot;);
    }
    public static void a(Object o) {
        System.out.println(&quot;2&quot;);
    }
    public static void main(String[] args) {
	    String s = null;
        a(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>integer comparison</string>
			<key>Id</key>
			<string>517</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>true true</string>
				<string>false false</string>
				<string>true false</string>
				<string>false true</string>
			</array>
			<key>a</key>
			<string>&lt;p&gt;If the value p being boxed is an int or short number between -128 and 127 (inclusive), then let r1 and r2 be the results of any two boxing conversions of p. It is always the case that r1 == r2.&lt;/p&gt;
&lt;p&gt;It&apos;s called the Flyweight pattern and is used to minimize memory usage. Those numbers are very likely to be used repeatedly, and autobox types like Integer are immutable (note this is done not just for Integer). Caching them makes it so there aren&apos;t lots of instances and reduces GC (Garbage Collection) work as well.&lt;/p&gt;

 
&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.7&quot;&gt;docs.oracle page&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What will be the output of this program?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
Integer a1 = 100;
Integer b1 = 100;

Integer a2 = 200;
Integer b2 = 200;

System.out.println((a1 == b1) + &quot; &quot; + (a2 == b2));
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>generic foo and bar</string>
			<key>Id</key>
			<string>518</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>public class Baz&lt;T extends Foo &amp; Bar&gt; {}</string>
				<string>public class Baz&lt;T extends Foo &amp;&amp; Bar&gt; {}</string>
				<string>public class Baz&lt;T extends Foo, Bar&gt; {}</string>
				<string>It is impossible</string>
			</array>
			<key>a</key>
			<string>&lt;p&gt;Type parameter can have multiple bounds. A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. All bounds must be separated with one ampersand symbol (&amp;).&lt;/p&gt;

 
&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/bounded.html&quot;&gt;docs.oracle page&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;You need to write a generic class that accepts only subclasses of Foo and Bar as a type parameter&lt;/h2&gt;
&lt;p&gt;How do you start?&lt;/p&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>syntax for function</string>
			<key>Id</key>
			<string>519</string>
			<key>Tags</key>
			<string>Java, Screen2</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>v1 and v4</string>
				<string>v2 and v3</string>
				<string>v2 and v4</string>
				<string>v1 and v3</string>
			</array>
			<key>a</key>
			<string>&lt;p&gt;void is a keyword that means that a function does not result a value.&lt;/p&gt;
&lt;p&gt;java.lang.Void is a reference type and as a result type (a function with a return value of type Void) it means that the function always returns null (it cannot return anything other than null, because Void has no instances).&lt;/p&gt;

 
&lt;a href=&quot;http://stackoverflow.com/a/15538295/1389883&quot;&gt;Stackoverflow answer&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;Which of the following methods won&apos;t compile successfully?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
public static Void v1() {
    return null;
}
public static Void v2() {
}
public static void v3() {
}
public static void v4() {
    return null;
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
	</array>
</dict>
</plist>
