<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>questions</key>
	<array>
		<dict>
			<key>Comment</key>
			<string>selectors in swift?</string>
			<key>Id</key>
			<string>60</string>
			<key>Tags</key>
			<string>Swift, Screen</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Yes</string>
				<string>No</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Yes, Swift has Selector&lt;/h2&gt;
&lt;p&gt;Swift itself doesn&apos;t use selectors — several of the ObjC patterns that make use of selectors are replaced by something else in Swift. (Use optional chaining instead of &lt;b&gt;respondsToSelector:&lt;/b&gt; tests, and don&apos;t use &lt;b&gt;performSelector:&lt;/b&gt; because it&apos;s not type safe.)&lt;/p&gt;

&lt;p&gt;When interacting with ObjC-based APIs that take selectors, you can use a string to represent one; e.g.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift”&gt;
myButton.addTarget(self, action: &quot;buttonTapped:&quot;, forControlEvents: .TouchUpInside)
let timer = NSTimer(timeInterval: 1, target: self, selector: &quot;test&quot;, userInfo: nil, repeats: false)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;b&gt;SEL&lt;/b&gt; type in ObjC maps to the &lt;b&gt;Selector&lt;/b&gt; type in Swift. Since a Selector can be automatically created from a string literal when needed, there&apos;s no need to pass Selector(&quot;string&quot;) or NSSelectorFromString(&quot;string”).&lt;/p&gt;

&lt;p&gt;Because selectors are an ObjC thing, their strings follow ObjC method naming rules—for a method that takes an argument, the selector ends with a colon (&quot;:&quot;). For example, the selector string for a method named test() is just &quot;test&quot;, but the selector for test(this:String) is &quot;test:”.&lt;/p&gt;

&lt;p&gt;Also note that the method referenced by the selector must be exposed to the ObjC runtime. This is already the case if it&apos;s in a class that (ultimately) inherits from NSObject, but if it&apos;s in a pure Swift class you&apos;ll need to preface that method&apos;s declaration with @objc.&lt;/p&gt;

&lt;a href=&quot;http://stackoverflow.com/questions/24007650/selector-in-swift&quot;&gt;Stack Overflow&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;Is there any selectors in Swift language (like Objective-C has)?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-objectivec”&gt;
[friend performSelector:@selector(tellAbout:) withObject:aNeighbor];
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>language features</string>
			<key>Id</key>
			<string>59</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>1+2+3+4</string>
			<key>answers</key>
			<array>
				<string>Tuples</string>
				<string>Extensions</string>
				<string>Protocols</string>
				<string>Generics</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Swift has all these features built-in&lt;/h2&gt;

&lt;p&gt;Swift is a multi-paradigm, compiled programming language created by Apple Inc. for iOS and OS X development. Introduced at Apple&apos;s 2014 Worldwide Developers Conference (WWDC), Swift is designed to work with Apple&apos;s Cocoa and Cocoa Touch frameworks and the large body of existing Objective-C code written for Apple products. Swift is intended to be more resilient to erroneous code (&quot;safer&quot;) than Objective-C, and also more concise. It is built with the LLVM compiler framework included in Xcode 6, and uses the Objective-C runtime, allowing C, Objective-C, C++ and Swift code to run within a single program, but its proprietary nature may hinder Swift&apos;s adoption outside the Apple ecosystem.&lt;/p&gt;

&lt;p&gt;Development on Swift began in 2010 by Chris Lattner, with the eventual collaboration of many other programmers at Apple. Swift took language ideas &quot;from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list&quot;. On June 2, 2014, the Worldwide Developers Conference (WWDC) application became the first publicly released app written in Swift. A beta version of the programming language was released to registered Apple developers at the conference, but the company did not promise that the final version of Swift would be source-compatible with the test version. Apple planned to make source code converters available if needed for the full release.&lt;/p&gt;

&lt;a href=“http://en.wikipedia.org/wiki/Swift_(programming_language)”&gt;Wiki&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What language features Swift offers?&lt;/h2&gt;
&lt;p&gt;(Select all)&lt;/p&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>array and div</string>
			<key>Id</key>
			<string>58</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>{2, 4, 6, 8}</string>
				<string>[2, 4, 6, 8]</string>
				<string>[2, 4, 6, 8, 10]</string>
				<string>[1, 2, 4, 6, 8, 10]</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;The output of this program is:&lt;/h2&gt;
&lt;p&gt;[2, 4, 6, 8, 10]&lt;/p&gt;

&lt;br&gt;
&lt;p&gt;This little script is very simple; the key points of the algorithm are as follows:&lt;p&gt;
&lt;p&gt;1. You create an empty (and mutable) array.&lt;/p&gt;
&lt;p&gt;2. The for loop iterates over the numbers from 1 to 10 (remember “…” is inclusive!).&lt;/p&gt;
&lt;p&gt;3. If the condition (that the number must be even) is met, you add it to the array.&lt;/p&gt;

&lt;p&gt;The above code is imperative in nature. The instructions tell the computer how to locate the even numbers by giving it explicit instructions that use basic control structures, in this case &lt;b&gt;if&lt;/b&gt; and &lt;b&gt;for-in&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;The code works just fine but the important bit—testing whether the number is even—is buried inside the for loop. There’s also some tight coupling, where the desired action of adding the number to the array is inside the condition. If you wanted to print each even number somewhere else in your app, there’s no good way to reuse code without resorting to copy-and-paste.&lt;/p&gt;

&lt;a href=&quot;http://www.raywenderlich.com/82599/swift-functional-programming-tutorial&quot;&gt;Blog post&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What will be the output of this program?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var evens = [Int]()
for i in 1...10 {
  if i % 2 == 0 {
    evens.append(i)
  }
}
println(evens)
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>inheritance + polymorphism</string>
			<key>Id</key>
			<string>57</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>1+2</string>
			<key>answers</key>
			<array>
				<string>Inheritance</string>
				<string>Polymorphism</string>
				<string>Multimethods</string>
				<string>Incapsulation</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;This code is using ‘inheritance’ and ‘polymorphism’ language features&lt;/h2&gt;
&lt;p&gt;Parametric polymorphism is a programming language feature to provide compile time polymorphism, Parametric Polymorphism is better know as Generics, a function using generics can be made to handle any time of data regardless its type while maintaining static type correctness.&lt;/p&gt;

&lt;p&gt;Both &lt;b&gt;Cat&lt;/b&gt; and &lt;b&gt;Dog&lt;/b&gt; are implementing the &lt;b&gt;Speaking&lt;/b&gt; protocol, they return different type from their speak function. Lets write a function that calls the Speakers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
func speak&lt;T: Speaking&gt;(speaker: T) -&gt; T.Voice {
  return speaker.speak()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;a href=&quot;http://nsomar.com/parametric-compile-time-polymorphism-in-swift/“&gt;Blog post&lt;/a&gt;

&lt;h3&gt;Protocols&lt;/h3&gt;
&lt;p&gt;A &lt;i&gt;protocol&lt;/i&gt; defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol doesn’t actually provide an implementation for any of these requirements—it only describes what an implementation will look like. The protocol can then be &lt;i&gt;adopted&lt;/i&gt; by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to &lt;i&gt;conform&lt;/i&gt; to that protocol.&lt;/p&gt;

&lt;p&gt;Protocols can require that conforming types have specific instance properties, instance methods, type methods, operators, and subscripts.&lt;/p&gt;

&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267&quot;&gt;Apple Documentation&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;What language features this code sample uses?&lt;/h2&gt;
&lt;p&gt;(select all)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
protocol Speaking {
  typealias Voice
  func speak () -&gt; Voice
}

class Dog : Speaking {
  func speak() -&gt; String {
    return &quot;BARK!&quot;
  }
}

class Cat : Speaking {
  func speak() -&gt; [String] {
    return [&quot;Meooww&quot;, &quot;Meooww&quot;]
  }
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>generic subclass</string>
			<key>Id</key>
			<string>56</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>5</string>
			<key>Correct Answers</key>
			<string>3+0</string>
			<key>answers</key>
			<array>
				<string></string>
				<string></string>
				<string></string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Error: classes derived from generic classes must also be generic&lt;/h2&gt;

&lt;p&gt;Subclasses are not permitted to specify a concrete type for a superclass&apos; type parameter.&lt;/p&gt;
&lt;p&gt;Bad line is #3. Correct code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class Boxed&lt;T&gt; {
  let v: T

  // 1
  init (v: T) { self.v = v }
}
 
// 2
class ExprR&lt;T&gt; : Boxed&lt;Expr&gt; {}
 
// 3
enum Expr {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Generics&lt;/h3&gt;
&lt;p&gt;&lt;i&gt;Generic code&lt;/i&gt; enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.&lt;/p&gt;

&lt;p&gt;Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code. For example, Swift’s &lt;b&gt;Array&lt;/b&gt; and &lt;b&gt;Dictionary&lt;/b&gt; types are both generic collections. You can create an array that holds &lt;b&gt;Int&lt;/b&gt; values, or an array that holds &lt;b&gt;String&lt;/b&gt; values, or indeed an array for any other type that can be created in Swift. Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.&lt;/p&gt;

&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html&quot;&gt;Apple Documentation&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;h2&gt;This code has bug. Can you spot it?&lt;/h2&gt;
&lt;p&gt;What line contains error?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class Boxed&lt;T&gt; {
  let v: T

  // 1
  init (v: T) { self.v = v }
}
 
// 2
class ExprR : Boxed&lt;Expr&gt; {}
 
// 3
enum Expr {}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>valid? 1</string>
			<key>Id</key>
			<string>55</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Yes</string>
				<string>No</string>
				<string>This code is valid if we will remove ; at the end of all lines</string>
				<string>This code is valid if we will add intitalizers for key and next fields</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;The code is totally good!&lt;/h2&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
&lt;h2&gt;Is that valid Swift code?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class LLNode&lt;T&gt; { 
      var key: T? 
      var next: LLNode&lt;T&gt;? 

      init() { } ;
};
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>bridging</string>
			<key>Id</key>
			<string>54</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>4</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>Swift can&apos;t call Objective-C code</string>
				<string>Swift can call Objective-C through the &apos;Bridging header&apos;</string>
				<string>Swift can call Objective-C code using so called &quot;Mix-and-use&quot; paradigm </string>
				<string>Swift can easily call some Objective-C code that has special modifications</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Mix and match (i.e. Bridging Header)&lt;/h2&gt;
&lt;p&gt;Swift’s compatibility with Objective-C lets you create a project that contains files written in either language. You can use this feature, called mix and match, to write apps that have a mixed-language codebase. Using mix and match, you can implement part of your app’s functionality using the latest Swift features and seamlessly incorporate it back into your existing Objective-C codebase.&lt;/p&gt;

&lt;p&gt;Objective-C and Swift files can coexist in a single project, whether the project was originally an Objective-C or Swift project. You can simply add a file of the other language directly to an existing project. This natural workflow makes creating mixed-language app and framework targets as straightforward as creating an app or framework target written in a single language.
The process for working with mixed-language targets differs slightly depending on whether you’re writing an app or a framework. The general import model for working with both languages within the same target is depicted below and described in more detail in the following sections.&lt;/p&gt;

&lt;h3&gt;To import Objective-C code into Swift&lt;/h3&gt;

&lt;p&gt;1) In your Objective-C bridging header file, import every Objective-C header you want to expose to Swift. For example:&lt;/p&gt;  &lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
    #import &quot;XYZCustomCell.h&quot;
    #import &quot;XYZCustomView.h&quot;
	#import &quot;XYZCustomViewController.h&quot;
&lt;/code&gt;&lt;/pre&gt;		

&lt;p&gt;2) Under Build Settings, make sure the Objective-C Bridging Header build setting under Swift Compiler - Code Generation has a path to the header. The path should be relative to your project, similar to the way your Info.plist path is specified in Build Settings. In most cases, you should not need to modify this setting. &lt;/p&gt;

&lt;p&gt;Any public Objective-C headers listed in this bridging header file will be visible to Swift. The Objective-C functionality will be available in any Swift file within that target automatically, without any import statements. Use your custom Objective-C code with the same Swift syntax you use with system classes.&lt;/p&gt;

&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_78&quot;&gt;Apple Documentation&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
&lt;h2&gt;Interoperability&lt;/h2&gt;
&lt;p&gt;How one can call existing Objective-C library code from within Swift?&lt;/p&gt;
&lt;/div&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>paradigms</string>
			<key>Id</key>
			<string>53</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>1+2+3</string>
			<key>answers</key>
			<array>
				<string>Imperative</string>
				<string>Functional</string>
				<string>Object-oriented</string>
				<string>Agent-oriented</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Swift is a multi-paradigm programming language&lt;/h2&gt;
&lt;p&gt;Swift makes use of these programming paradigms: object-oriented, functional, imperative.&lt;/p&gt;

&lt;p&gt;Swift is compiled programming language created by Apple Inc. for iOS and OS X development. Introduced at Apple&apos;s 2014 Worldwide Developers Conference (WWDC), Swift is designed to work with Apple&apos;s Cocoa and Cocoa Touch frameworks and the large body of existing Objective-C code written for Apple products. Swift is intended to be more resilient to erroneous code (&quot;safer&quot;) than Objective-C, and also more concise. It is built with the LLVM compiler framework included in Xcode 6, and uses the Objective-C runtime, allowing C, Objective-C, C++ and Swift code to run within a single program.&lt;/p&gt;

&lt;h3&gt;Basic features&lt;/h3&gt;

&lt;p&gt;Swift is a replacement for the Objective-C language that employs contemporary programming language theory concepts and strives to present a simpler syntax. During its introduction, it was described simply as &quot;Objective-C without the C”.&lt;/p&gt;
&lt;p&gt;By default, Swift does not expose pointers and other unsafe accessors, contrary to Objective-C, which uses pointers pervasively to refer to object instances. Additionally, Objective-C&apos;s use of a Smalltalk-like syntax for making method calls has been replaced with a dot-notation style and namespace system more familiar to programmers from other common OO languages like JavaScript, Java or C#. Swift introduces true named parameters and retains key Objective-C concepts, including protocols, closures and categories, often replacing former syntax with cleaner versions and allowing these concepts to be applied to other language structures, like enums.&lt;/p&gt;

&lt;a href=&quot;http://en.wikipedia.org/wiki/Swift_(programming_language)&quot;&gt;Wiki&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
&lt;h2&gt;What programming paradigms Swift language “includes”?&lt;/h2&gt;
&lt;p&gt;(Select all)&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
// Sample Swift language code:
import UIKit

class ScoreController: UIViewController {
    @IBOutlet var lblTotalQuestion: UITextField!
    @IBOutlet var lblCorrect: UITextField!
    @IBOutlet var lblLevel: UITextField!
    @IBOutlet var lblTopic: UITextField!

    @IBAction func onContinue(){
        performSegueWithIdentifier(&quot;goToMainMenu&quot;,sender:self)
    }
}&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>ref cycle</string>
			<key>Id</key>
			<string>52</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>5</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Yes. There is a bug in this code</string>
				<string>No. Code has no bugs</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;This code has ‘strong reference cycle’ bug&lt;/h2&gt;
&lt;p&gt;There is a &lt;i&gt;strong reference cycle&lt;/i&gt; between &lt;b&gt;Master&lt;/b&gt; and &lt;b&gt;Detail&lt;/b&gt;, with &lt;b&gt;Master&lt;/b&gt; creating an instance of &lt;b&gt;Detail&lt;/b&gt; and storing a reference to it, and &lt;b&gt;Detail&lt;/b&gt; storing a reference to the instance of its &lt;b&gt;Master&lt;/b&gt; creator. In both cases, references are strong, which means that none of the 2 instances will ever be deallocated, causing a memory leak.&lt;/p&gt;
&lt;p&gt;To solve the problem it’s necessary to break at least one of the 2 strong relationships, by using either the &lt;b&gt;weak&lt;/b&gt; or &lt;b&gt;unowned&lt;/b&gt; modifier. The differences between the 2 modifiers is:&lt;/p&gt;
		&lt;h3&gt;unowned&lt;/h3&gt;
		&lt;p&gt;The reference is assumed to always have a value during its lifetime - as a consequence, the property must be of non-optional type.&lt;/p&gt;
		&lt;h3&gt;weak&lt;/h3&gt;
		&lt;p&gt;At some point it’s possible for the reference to have no value - as a consequence, the property must be of optional type.&lt;/p&gt;
&lt;p&gt;In the above code example, the proper solution is to define in &lt;b&gt;Detail&lt;/b&gt; the reference to &lt;b&gt;Master&lt;/b&gt; as &lt;b&gt;unowned&lt;/b&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class Detail {
    unowned var master: Master
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;Source&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
&lt;h2&gt;Can you spot bug here?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class Master {
    lazy var detail: Detail = Detail(master: self)
    
    init() {
        println(&quot;Master init&quot;)
    }
    
    deinit {
        println(&quot;Master deinit&quot;)
    }
}

class Detail {
    var master: Master
    
    init(master: Master) {
        println(&quot;Detail init&quot;)
        self.master = master
    }
    
    deinit {
        println(&quot;Detail deinit&quot;)
    }
}

func createMaster() {
    var master: Master = Master()
    var detail = master.detail
}
    
createMaster()
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>array length</string>
			<key>Id</key>
			<string>51</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>6</string>
				<string>5</string>
				<string>Code is invalid</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;The value is 5&lt;/h2&gt;
&lt;p&gt;The &lt;b&gt;len&lt;/b&gt; variable is equal to 5, meaning that &lt;b&gt;array1&lt;/b&gt; has 5 elements, whereas &lt;b&gt;array2&lt;/b&gt; has 6 elements:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
array1 = [1, 2, 3, 4, 5]
array2 = [1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When array1 is assigned to array2, a copy of array1 is actually created and assigned.&lt;/p&gt;
&lt;p&gt;The reason is that swift arrays are value types (implemented as structs) and not reference types (i.e. classes). When a value type is assigned to a variable, passed as argument to a function or method, or otherwise moved around, a copy of it is actually created and assigned or passed. Note that swift dictionaries are also value types, implemented as structs.&lt;/p&gt;
&lt;p&gt;Value types in swift are:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;structs (incl. arrays and dictionaries)&lt;/li&gt;
	&lt;li&gt;enumerations&lt;/li&gt;
		&lt;li&gt;basic data types (boolean, integer, float, etc.)&lt;/li&gt;
&lt;/ul&gt;

&lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;Source&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
&lt;h2&gt;What is the value of len variable?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var array1 = [1, 2, 3, 4, 5]
var array2 = array1
array2.append(6)
var len = array1.count
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>reduce</string>
			<key>Id</key>
			<string>50</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>4</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>result is Double</string>
				<string>result is Float</string>
				<string>result is Single</string>
				<string>result is a Function</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;result is a Double&lt;/h2&gt;

&lt;p&gt;&lt;b&gt;result&lt;/b&gt; is calculated as the sum of the distance of all planets.&lt;/p&gt;
&lt;p&gt;Given an initial value and a closure, the &lt;b&gt;reduce&lt;/b&gt; method of the Array&lt;T&gt; struct type returns a single value obtained by recursively applying the closure to each element of the array. The closure takes the value calculated at the previous step (or the initial value if it’s the first iteration) and the current array element, and is expected to return a value of the same type of the initial value.&lt;/p&gt;
&lt;p&gt;In the above code, the closure returns the sum of what calculated at the previous step, plus the value of the distanceFromSun property for the current element. The end result is the sum of the distances of all planets.&lt;/p&gt;
&lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;Source&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
&lt;h2&gt;What is the type of result variable?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
struct Planet {
    var name: String
    var distanceFromSun: Double
}

let planets = [
    Planet(name: &quot;Mercury&quot;, distanceFromSun: 0.387),
    Planet(name: &quot;Venus&quot;, distanceFromSun: 0.722),
    Planet(name: &quot;Earth&quot;, distanceFromSun: 1.0),
    Planet(name: &quot;Mars&quot;, distanceFromSun: 1.52),
    Planet(name: &quot;Jupiter&quot;, distanceFromSun: 5.20),
    Planet(name: &quot;Saturn&quot;, distanceFromSun: 9.58),
    Planet(name: &quot;Uranus&quot;, distanceFromSun: 19.2),
    Planet(name: &quot;Neptune&quot;, distanceFromSun: 30.1)
]

var result = planets.reduce(0) { $0 + $1.distanceFromSun }
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>case</string>
			<key>Id</key>
			<string>49</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>Raw values is the data that case items &quot;contain&quot;</string>
				<string>Raw values are used to associate constant values to enum cases</string>
				<string>Associated values describe type of enum case</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;&lt;b&gt;Raw values&lt;/b&gt; are used to associate constant (literal) values to enum cases&lt;/h2&gt;
&lt;p&gt;The value type is part of the enum type, and each enum case must specify a unique raw value (duplicate values are not allowed).&lt;/p&gt;
&lt;p&gt;The following example shows an enum with raw values of type Int:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
enum IntEnum : Int {
    case ONE = 1
    case TWO = 2
    case THREE = 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An enum value can be converted to its raw value by using the &lt;b&gt;rawValue&lt;/b&gt; property:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var enumVar: IntEnum = IntEnum.TWO
var rawValue: Int = enumVar.rawValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A raw value can be converted to an enum instance by using a dedicated initializer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var enumVar: IntEnum? = IntEnum(rawValue: 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;i&gt;Associated values&lt;/i&gt; are used to associate arbitrary data to a specific enum case. Each enum case can have zero or more associated values, declared as a tuple in the case definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
enum AssociatedEnum {
    case EMPTY
    case WITH_INT(value: Int)
    case WITH_TUPLE(value: Int, text: String, data: [Float])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas the type(s) associated to a case are part of the enum declaration, the associated value(s) are instance specific, meaning that an enum case can have different associated values for different enum instances.&lt;/p&gt;

&lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;Source&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
&lt;h2&gt;In Swift enumerations, what’s the difference between raw values and associated values?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
enum IntEnum {
    case ONE = 1
    case TWO = 2
    case THREE = 3
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>mutating</string>
			<key>Id</key>
			<string>48</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Add mutating keyword</string>
				<string>Add inline keyword to function definition</string>
				<string>Use add instead of append</string>
				<string>Cast Int to NSInteger </string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Structures are immutable by default&lt;/h2&gt;

&lt;p&gt;Structures are value types. By default, the properties of a value type cannot be modified from within its instance methods.&lt;/p&gt;
&lt;p&gt;However, you can optionally allow such modification to occur by declaring the instance methods as ‘mutating’; e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
struct IntStack {
  var items = [Int]()
  mutating func add(x: Int) {
    items.append(x) // All good!
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;Source&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;How can you fix the error?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
struct IntStack {
  var items = [Int]()

  func add(x: Int) {
    items.append(x) // Compile time error here.
  }
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>explicit unwrapping</string>
			<key>Id</key>
			<string>47</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>Line 1 has error</string>
				<string>Line 2 has error</string>
				<string>Line 3 has error</string>
				<string>Function &apos;printString&apos; contains error</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Line 2 has error - unwrapping could possibly throw error&lt;/h2&gt;
&lt;p&gt;The second line uses the &lt;b&gt;stringForKey&lt;/b&gt; method of NSUserDefaults, which returns an optional, to account for the key not being found, or for the corresponding value not being convertible to a string.&lt;/p&gt;
&lt;p&gt;During its execution, if the key is found and the corresponding value is a string, the above code works correctly. But if the key doesn’t exist, or the corresponding value is not a string, the app crashes with the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
fatal error: unexpectedly found nil while unwrapping an Optional value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason is that the forced unwrapping operator ! is attempting to force unwrap a value from a nil optional. The forced unwrapping operator should be used only when an optional is known to contain a non-nil value.&lt;/p&gt;
&lt;p&gt;The solution consists of making sure that the optional is not nil before force-unwrapping it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
let userPref = defaults.stringForKey(&quot;userPref&quot;)
if userPref != nil {
    printString(userPref!)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An even better way is by using &lt;i&gt;optional binding&lt;/i&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
if let userPref = defaults.stringForKey(&quot;userPref&quot;) {
    printString(userPref)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;Source&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Can you spot the error here?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var defaults = NSUserDefaults.standardUserDefaults()
var userPref = defaults.stringForKey(&quot;userPref&quot;)!
printString(userPref)

func printString(string: String) {
    println(string)
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>implicit cast</string>
			<key>Id</key>
			<string>46</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>4</string>
			<key>answers</key>
			<array>
				<string>Line 1</string>
				<string>Line 2</string>
				<string>Line 3</string>
				<string>Line 4</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Line 4 contains error&lt;/h2&gt;
&lt;p&gt;Swift doesn’t define any implicit cast between data types, even if they are conceptually almost identical (like UInt and Int).&lt;/p&gt;
&lt;p&gt;To fix the error, rather than casting, an &lt;b&gt;explicit conversion&lt;/b&gt; is required. In the sample code, all expression operands must be converted to a common same type, which in this case is Double:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var result = Double(op1) + Double(op2) + op3
&lt;/code&gt;&lt;/pre&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Consider the following code:&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
// 1
let op1: Int = 1

// 2
let op2: UInt = 2

// 3
let op3: Double = 3.34

// 4
var result = op1 + op2 + op3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Where is the error?&lt;/h2&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>components of NSIndexPath</string>
			<key>Id</key>
			<string>45</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>Section and column</string>
				<string>Row and column</string>
				<string>Section and row</string>
				<string>Row and count</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;The main properties are: Section and Row&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    let section: Int = indexPath.section
    let row: Int = indexPath.row
 
    let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate
    let tags:[String:Any] = appDelegate.model.getTags()

    let txt = tags[row];
    ...
}
&lt;/code&gt;&lt;/pre&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What are the main properties of NSIndexPath?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
extension UITableView {
    func getAllCheckedCells()-&gt;[NSIndexPath]{
        ... 
    }
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>string len</string>
			<key>Id</key>
			<string>44</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>Use line 1</string>
				<string>Use line 2</string>
				<string>Use line 3</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Use global function - count&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var test1 = “SuperString”

// 3 - Good:
let len: Int = count(test) 

// or without explicit type:
let len2 = count(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Counting characters in Swift&lt;/h3&gt;
&lt;p&gt;The most precise, but and also most costly in terms of performance is the &lt;b&gt;count&lt;/b&gt; global function.&lt;/p&gt;
&lt;p&gt;It will return the actual number of Unicode characters in a String, so it&apos;s the most correct alternative in the sense that, if you&apos;d print the string and count characters by hand, you&apos;d get the same result.&lt;/p&gt;

&lt;p&gt;However, because of the way Strings are implemented in Swift, characters don&apos;t always take up the same amount of memory, so be aware that this behaves quite differently than the usual character count methods in other languages.&lt;/p&gt;
&lt;p&gt;For example, you can also explicitly bridge to Objective-C and use the NSString &lt;b&gt;length&lt;/b&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
test1.bridgeToObjectiveC().length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is effectively the same as &lt;b&gt;test1.utf16Count&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;But, as noted below, the returned value is not guaranteed to be the same as that of calling count().&lt;/p&gt;
&lt;p&gt;From the language reference:&lt;/p&gt;

&lt;q&gt;Different Unicode characters and different representations of the same Unicode character can require different amounts of memory to store. Because of this, characters in Swift do not each take up the same amount of memory within a string’s representation. As a result, the length of a string cannot be calculated without iterating through the string to consider each of its characters in turn. If you are working with particularly long string values, be aware that the countElements function must iterate over the characters within a string in order to calculate an accurate character count for that string.
Note also that the character count returned by countElements is not always the same as the length property of an NSString that contains the same characters. The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode characters within the string. To reflect this fact, the length property from NSString is called utf16Count when it is accessed on a Swift String value.&lt;/q&gt;

&lt;a href=“http://stackoverflow.com/questions/24037711/get-the-length-of-a-string”&gt;Stackoverflow&lt;/a&gt;
&lt;br&gt;
&lt;a href=“https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html”&gt;Apple Documentation&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;How to get string length in Swift?&lt;/h2&gt;
    &lt;p&gt;(Swift 1.2)&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var test1: String = “SuperString”

// 1
let len: Int = test1.length

// 2
let len: Int = test.count

// 3
let len: Int = count(test) 
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>implicit unwrapping</string>
			<key>Id</key>
			<string>43</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>If we will use lblFirst like a normal variable (lblFirst.text = &quot;Hello&quot;) -&gt; optional unwrapping will be done automatically</string>
				<string>Line 1 has error. Use line 2</string>
				<string>lblFirst can only contain non-nil variable</string>
				<string>lblFirst is a lazy-initialized variable</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;lblFirst is an Implicitly Unwrapped Optional value&lt;/h2&gt;
&lt;p&gt;We don’t have to unwrap it manually. We can use it like a usual non-optional variable. Swift runtime will automatically unwrap it for us. See example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
@IBOutlet var lblFirst: UILabel!
@IBOutlet var lblSecond: UILabel?

// initialize them later in init() function
// …

// and now can use .text property like that:

// 1 - no ? or ! required, the value is unwrapped automatically!
// will throw error if lblFirst is nil
lblFirst.text = “I will throw if lblFirst is nil”

// 2 - 
// will throw error if lblSecond is nil
lblSecond?.text = “Question mark or exclamation mark is required”

// will not throw error even though lblSecond is nil
lblSecond!.text = “Or like that”
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Implicitly Unwrapped Optionals&lt;/h3&gt;
&lt;p&gt;Swift also has something called implicitly unwrapped optionals. These are optionals that do not need to be unwrapped using either forced unwrapping (!) or optional binding because they are unwrapped implicitly (automatically). They are declared using an exclamation mark (!) rather than a question mark (?). 
You often see implicitly unwrapped optionals when working with Interface Builder outlets (IBOutlet properties). For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
@IBOutlet weak var lblDescription: UILabel!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code, the lblDescription outlet property has an exclamation mark after it, indicating it is implicitly unwrapped. This allows you to access the property without unwrapping it.&lt;/p&gt;

&lt;p&gt;In this example, the outlet property isn&apos;t &lt;i&gt;guaranteed&lt;/i&gt; to contain a reference to a label but it absolutely &lt;i&gt;should&lt;/i&gt;. If it doesn&apos;t contain a reference to a label, it means that the connection between the outlet and the label has been broken. In that case, it&apos;s OK to have a run-time error because you want to know that the connection is broken so that you can fix it!&lt;/p&gt;
&lt;p&gt;Obviously, in cases where you&apos;re not 100 percent sure that a constant or variable contains a value you should use a regular optional instead.&lt;/p&gt;
&lt;a href=“https://www.iphonelife.com/blog/31369/swift-101-working-swifts-new-optional-values”&gt;Blog post&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What is the difference between line 1 and line 2 variables?&lt;/h2&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
// 1
@IBOutlet var lblFirst: UILabel!

// 2
@IBOutlet var lblSecond: UILabel?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>optional value</string>
			<key>Id</key>
			<string>42</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Line 1 has error</string>
				<string>Line 2 has error</string>
				<string>Line 3 has error</string>
				<string>Code has no errors and will be compiled</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Line 1 has error&lt;/h2&gt;
    &lt;p&gt;Initializer required because lblTopic is not an optional value&lt;/p&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class ScoreController: UIViewController {
	// 1 - Error - ’IBOutlet&apos; property has non-optional type &apos;UITextField&apos;
    @IBOutlet var lblTopic: UITextField
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Correct way is to use optional:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class ScoreController: UIViewController {
	// can be initialized later (manually in code) or automatically with Storyboard
   	@IBOutlet var lblTopic: UITextField? 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;…and then connect control to the outlet in XCode Storyboard.&lt;/p&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Do you see error here?&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class ScoreController: UIViewController {
	// 1
   	@IBOutlet var lblTopic: UITextField

	// 2
   	@IBOutlet var lblLevel: UITextField!  

	// 3
	// Optional (iPad Storyboard only)
   	@IBOutlet var lblCorrect: UITextField?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>both lines with error</string>
			<key>Id</key>
			<string>41</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Both lines (1 and 2) contain errors</string>
				<string>Line 1 has error</string>
				<string>Line 2 has error</string>
				<string>No errors here</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Both lines contain errors&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
	func tst(){
        var strDesc: String = &quot;&quot;;
        let strPicture: String = &quot;Some_string&quot;;
        
        // 1 - Type &apos;Int&apos; does not conform to protocol &apos;BooleanType&apos;
        // != 0 required
		if(count(strPicture)){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }
        
        // 2 - Operand of postfix &apos;!&apos; should have optional type; type is &apos;Int&apos;
        // space required
		if(count(strPicture)!=0){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }

		…
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3&gt;Good tst function:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
	func tst(){
        var strDesc: String = &quot;&quot;;
        let strPicture: String = &quot;Some_string&quot;;
                
        if(count(strPicture) != 0){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }

		…
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What lines contain errors?&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
	func tst(){
        var strDesc: String = &quot;&quot;;
        let strPicture: String = &quot;Some_string&quot;;
        
        // 1
        if(count(strPicture)){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }
        
        // 2
        if(count(strPicture)!=0){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>NS is nextstep </string>
			<key>Id</key>
			<string>40</string>
			<key>Tags</key>
			<string>Swift, IT History</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>NewStyle</string>
				<string>NextStep</string>
				<string>NumericSpec</string>
				<string>NumSpecified</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;NS stands for NeXTSTEP&lt;/h2&gt;
&lt;div&gt;
&lt;p&gt;&lt;b&gt;NeXTSTEP&lt;/b&gt; (also stylized as &lt;b&gt;NeXTstep&lt;/b&gt;, &lt;b&gt;NeXTStep&lt;/b&gt;, and &lt;b&gt;NEXTSTEP&lt;/b&gt;) is an object-oriented, multitasking operating system which was developed by NeXT Computer to run on its range of proprietary workstation computers, such as the NeXTcube. It was later ported to several other computer architectures.&lt;/p&gt;

&lt;p&gt;A preview release of NeXTSTEP (version 0.8) was shown with the launch of the NeXT Computer on October 12, 1988. The first full release, NeXTSTEP 1.0, shipped on September 18, 1989. The last version, 3.3, was released in early 1995, by which time it ran on not only the Motorola 68000 family processors used in NeXT computers, but also on Intel x86, Sun SPARC, and HP PA-RISC-based systems.&lt;/p&gt;

&lt;p&gt;Apple purchased NeXT in 1997 for $429 million and 1.5 million shares of Apple stock. As part of the agreement, Steve Jobs, Chairman and CEO of NeXT Software, returned to Apple, the company he had cofounded in 1976. The merger promised to marry software from NeXT with Apple&apos;s hardware platforms, eventually resulting in OS X and iOS. Parts of these operating systems incorporated the OPENSTEP foundation.&lt;/p&gt;

&lt;h3&gt;1987–93: NeXT Computer&lt;/h3&gt;
&lt;h4&gt;First generation&lt;/h4&gt;

&lt;p&gt;NeXT changed its business plan in mid-1986. The company decided to develop both computer hardware and software, instead of just a low-end workstation. A team led by Avie Tevanian, who had joined the company after working as one of the Mach kernel engineers at Carnegie Mellon University, was to develop the NeXTSTEP operating system. The hardware division, led by Rich Page, one of the cofounders who had previously led the Apple Lisa team, designed and developed the hardware. NeXT&apos;s first factory was completed in Fremont, California in 1987. It was capable of producing 150,000 machines per year. NeXT&apos;s first workstation was officially named the NeXT Computer, although it was widely referred to as &quot;the cube&quot; because of its distinctive case, a 1 ft magnesium cube, an edict of Jobs&apos; designed by Apple IIc case designer Frogdesign.&lt;/p&gt;

&lt;p&gt;The original design team had anticipated releasing the computer for US$ 3,000 in spring of 1987 to be ready for sale by summer of that year. Prototype workstations were eventually shown to standing ovations on October 12, 1988. The NeXT Computer was revealed at a lavish (invitation only) gala launch event &quot;NeXT Introduction - the Introduction to the NeXT Generation of Computers for Education&quot; at the Louise M. Davies Symphony Hall, San Francisco, California on Wednesday October 12 1988. The following day, selected educators and software developers were invited (for $100 registration fee) to attend the first public technical overview of the NeXT computer at an event called &quot;The NeXT Day&quot; held at the San Francisco Hilton. This event gave developers interested in developing NeXT software an insight into the software architecture, object-oriented programming and developing for the NeXT Computer. The luncheon speaker was Steve Jobs.&lt;/p&gt;

&lt;p&gt;The first machines were tested in 1989, after which NeXT started selling limited numbers to universities with a beta version of the NeXTSTEP operating system installed. Initially the NeXT Computer was targeted at US higher education establishments only, with a base price of $6,500. The machine was widely reviewed in magazines, generally concentrating on the hardware. When asked if he was upset that the computer&apos;s debut was delayed by several months, Jobs responded, &quot;Late? This computer is five years ahead of its time!”&lt;/p&gt;

&lt;p&gt;The NeXT Computer was based on the new 25 MHz Motorola 68030 central processing unit (CPU). The Motorola 88000 RISC chip was originally considered, but was not available in sufficient quantities. It included between 8 and 64 MB of random access memory (RAM), a 256 MB magneto-optical (MO) drive, a 40 MB (swap-only), 330 MB, or 660 MB hard drive, 10Base-2 Ethernet, NuBus and a 17-inch &lt;i&gt;MegaPixel&lt;/i&gt; grayscale display measuring 1120 by 832 pixels. In 1989 a typical new PC, Macintosh, or Amiga computer included a few MB of RAM, a 640×480 16-color or 320x240 4000-color display, a 10 to 20 megabyte hard drive and few networking capabilities. It also was the first computer to ship with a general-purpose DSP chip (Motorola 56001) on the mother board. This was used to support sophisticated music and sound processing, including the Music Kit software.&lt;/p&gt;

&lt;p&gt;The magneto-optical drive manufactured by Canon was used as the primary mass storage device. These drives were relatively new to the market, and the NeXT was the first computer to use them. They were cheaper than hard drives (blank media especially so: though each had a cost of $150 to Canon, Jobs&apos; typically forthright negotiations saw Canon agree to a retail of only $50 apiece) but slower (with an average seek time of 96 ms). The design made it impossible to move files between computers without a network, since each NeXT Computer had only one MO drive and the disk could not be removed without shutting down the system. Storage options proved challenging for the first NeXT Computers. The magneto-optical media was relatively expensive and had performance and reliability problems despite being faster than a floppy drive. The drive was not sufficient to run as the primary medium running the NeXTSTEP operating system both in terms of speed and capacity.&lt;/p&gt;

&lt;p&gt;In 1989, NeXT struck a deal for former Compaq reseller Businessland to sell NeXT computers in select markets nationwide. Selling through a retailer was a major change from NeXT&apos;s original business model of only selling directly to students and educational institutions. Businessland founder David Norman predicted that sales of the NeXT Computer would surpass sales of Compaq computers after 12 months.&lt;/p&gt;

&lt;p&gt;In 1989, Canon invested US$100 million in NeXT, giving it a 16.67 percent stake, making NeXT worth almost $600 million. Canon invested in NeXT with the condition that it would be able to use the NeXTSTEP environment with its own workstations, which would mean a greatly expanded market for the software. After NeXT exited the hardware business, Canon produced a line of PCs, called &lt;i&gt;object.station&lt;/i&gt;, including models 31, 41, 50 and 52, specifically designed to run NeXTSTEP/Intel. Canon also served as NeXT&apos;s distributor in Japan.&lt;/p&gt;

&lt;p&gt;The first NeXT computers were released on the retail market in 1990, for $9,999. NeXT&apos;s original investor Ross Perot resigned from the board of directors in June 1991 to dedicate more time to Perot Systems, a Plano, Texas-based systems integrator.&lt;/p&gt;

&lt;a href=&quot;http://en.wikipedia.org/wiki/NeXT&quot;&gt;Wiki&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What NS prefix in NSIndexPath stands for?&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
	// toggle checkbox
    var cell:UITableViewCell = tableView.cellForRowAtIndexPath(indexPath)!
        
    if(cell.accessoryType == UITableViewCellAccessoryType.None){
    	cell.accessoryType = UITableViewCellAccessoryType.Checkmark
    }else{
    	cell.accessoryType = UITableViewCellAccessoryType.None
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
	</array>
</dict>
</plist>
