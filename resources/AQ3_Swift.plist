<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>questions</key>
	<array>
		<dict>
			<key>Comment</key>
			<string></string>
			<key>Id</key>
			<string>48</string>
			<key>Tags</key>
			<string>Swift, Screen</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string></string>
				<string></string>
				<string></string>
				<string></string>
			</array>
			<key>a</key>
			<string></string>
			<key>q</key>
			<string></string>
		</dict>
		<dict>
			<key>Comment</key>
			<string></string>
			<key>Id</key>
			<string>48</string>
			<key>Tags</key>
			<string>Swift, Screen</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string></string>
				<string></string>
				<string></string>
				<string></string>
			</array>
			<key>a</key>
			<string></string>
			<key>q</key>
			<string></string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>explicit unwrapping</string>
			<key>Id</key>
			<string>47</string>
			<key>Tags</key>
			<string>Swift, Screen</string>
			<key>Level</key>
			<string>2</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>Line 1 has error</string>
				<string>Line 2 has error</string>
				<string>Line 3 has error</string>
				<string>Function &apos;printString&apos; contains error</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Line 2 has error - unwrapping could possibly throw error&lt;/h2&gt;
&lt;p&gt;The second line uses the &lt;b&gt;stringForKey&lt;/b&gt; method of NSUserDefaults, which returns an optional, to account for the key not being found, or for the corresponding value not being convertible to a string.&lt;/p&gt;
&lt;p&gt;During its execution, if the key is found and the corresponding value is a string, the above code works correctly. But if the key doesn’t exist, or the corresponding value is not a string, the app crashes with the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
fatal error: unexpectedly found nil while unwrapping an Optional value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason is that the forced unwrapping operator ! is attempting to force unwrap a value from a nil optional. The forced unwrapping operator should be used only when an optional is known to contain a non-nil value.&lt;/p&gt;
&lt;p&gt;The solution consists of making sure that the optional is not nil before force-unwrapping it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
let userPref = defaults.stringForKey(&quot;userPref&quot;)
if userPref != nil {
    printString(userPref!)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An even better way is by using &lt;i&gt;optional binding&lt;/i&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
if let userPref = defaults.stringForKey(&quot;userPref&quot;) {
    printString(userPref)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;Source&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Can you spot the error here?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift”&gt;
var defaults = NSUserDefaults.standardUserDefaults()
var userPref = defaults.stringForKey(&quot;userPref&quot;)!
printString(userPref)

func printString(string: String) {
    println(string)
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>implicit cast</string>
			<key>Id</key>
			<string>46</string>
			<key>Tags</key>
			<string>Swift, Screen</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>Line 1</string>
				<string>Line 2</string>
				<string>Line 3</string>
				<string>There is no error in this code</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Line 3 contains error&lt;/h2&gt;
&lt;p&gt;Swift doesn’t define any implicit cast between data types, even if they are conceptually almost identical (like UInt and Int).&lt;/p&gt;
&lt;p&gt;To fix the error, rather than casting, an &lt;b&gt;explicit conversion&lt;/b&gt; is required. In the sample code, all expression operands must be converted to a common same type, which in this case is Double:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var result = Double(op1) + Double(op2) + op3
&lt;/code&gt;&lt;/pre&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Consider the following code:&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift”&gt;
// 1
let op1: Int = 1

// 2
let op2: UInt = 2

// 3
let op3: Double = 3.34

// 4
var result = op1 + op2 + op3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Where is the error?&lt;/h2&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>components of NSIndexPath</string>
			<key>Id</key>
			<string>45</string>
			<key>Tags</key>
			<string>Swift, Screen</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>Section and column</string>
				<string>Row and column</string>
				<string>Section and row</string>
				<string>Row and count</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;The main properties are: Section and Row&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    let section: Int = indexPath.section
    let row: Int = indexPath.row
 
    let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate
    let tags:[String:Any] = appDelegate.model.getTags()

    let txt = tags[row];
    ...
}
&lt;/code&gt;&lt;/pre&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What are the main properties of NSIndexPath?&lt;/h2&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift”&gt;
extension UITableView {
    func getAllCheckedCells()-&gt;[NSIndexPath]{
        var out = [NSIndexPath]()
        
        let cnt = self.numberOfRowsInSection(0)
        for i in 0..&lt;cnt {
            var indexPath: NSIndexPath = NSIndexPath(forItem: i, inSection: 0)
            
            var cell:UITableViewCell? = self.cellForRowAtIndexPath(indexPath)
            if(cell?.accessoryType == UITableViewCellAccessoryType.Checkmark){
                out.append(indexPath)
            }
        }
        
        return out
    }
}
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>string len</string>
			<key>Id</key>
			<string>44</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>1</string>
			<key>Correct Answers</key>
			<string>3</string>
			<key>answers</key>
			<array>
				<string>Use line 1</string>
				<string>Use line 2</string>
				<string>Use line 3</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;Use global function - count&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var test1 = “SuperString”

// 3 - Good:
let len: Int = count(test) 

// or without explicit type:
let len2 = count(test)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Counting characters in Swift&lt;/h3&gt;
&lt;p&gt;The most precise, but and also most costly in terms of performance is the &lt;b&gt;count&lt;/b&gt; global function.&lt;/p&gt;
&lt;p&gt;It will return the actual number of Unicode characters in a String, so it&apos;s the most correct alternative in the sense that, if you&apos;d print the string and count characters by hand, you&apos;d get the same result.&lt;/p&gt;

&lt;p&gt;However, because of the way Strings are implemented in Swift, characters don&apos;t always take up the same amount of memory, so be aware that this behaves quite differently than the usual character count methods in other languages.&lt;/p&gt;
&lt;p&gt;For example, you can also explicitly bridge to Objective-C and use the NSString &lt;b&gt;length&lt;/b&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
test1.bridgeToObjectiveC().length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is effectively the same as &lt;b&gt;test1.utf16Count&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;But, as noted below, the returned value is not guaranteed to be the same as that of calling count().&lt;/p&gt;
&lt;p&gt;From the language reference:&lt;/p&gt;

&lt;q&gt;Different Unicode characters and different representations of the same Unicode character can require different amounts of memory to store. Because of this, characters in Swift do not each take up the same amount of memory within a string’s representation. As a result, the length of a string cannot be calculated without iterating through the string to consider each of its characters in turn. If you are working with particularly long string values, be aware that the countElements function must iterate over the characters within a string in order to calculate an accurate character count for that string.
Note also that the character count returned by countElements is not always the same as the length property of an NSString that contains the same characters. The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode characters within the string. To reflect this fact, the length property from NSString is called utf16Count when it is accessed on a Swift String value.&lt;/q&gt;

&lt;a href=“http://stackoverflow.com/questions/24037711/get-the-length-of-a-string”&gt;Stackoverflow&lt;/a&gt;
&lt;br&gt;
&lt;a href=“https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html”&gt;Apple Documentation&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;How to get string length in Swift?&lt;/h2&gt;
    &lt;p&gt;(Swift 1.2)&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
var test1: String = “SuperString”

// 1
let len: Int = test1.length

// 2
let len: Int = test.count

// 3
let len: Int = count(test) 
&lt;/code&gt;&lt;/pre&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>implicit unwrapping</string>
			<key>Id</key>
			<string>43</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>If we will use lblFirst like a normal variable (lblFirst.text = &quot;Hello&quot;) -&gt; optional unwrapping will be done automatically</string>
				<string>Line 1 has error. Use line 2</string>
				<string>lblFirst can only contain non-nil variable</string>
				<string>lblFirst is a lazy-initialized variable</string>
			</array>
			<key>a</key>
			<string>&lt;h2&gt;lblFirst is an Implicitly Unwrapped Optional value&lt;/h2&gt;
&lt;p&gt;We don’t have to unwrap it manually. We can use it like a usual non-optional variable. Swift runtime will automatically unwrap it for us. See example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
@IBOutlet var lblFirst: UILabel!
@IBOutlet var lblSecond: UILabel?

// initialize them later in init() function
// …

// and now can use .text property like that:

// 1 - no ? or ! required, the value is unwrapped automatically!
// will throw error if lblFirst is nil
lblFirst.text = “I will throw if lblFirst is nil”

// 2 - 
// will throw error if lblSecond is nil
lblSecond?.text = “Question mark or exclamation mark is required”

// will not throw error even though lblSecond is nil
lblSecond!.text = “Or like that”
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Implicitly Unwrapped Optionals&lt;/h3&gt;
&lt;p&gt;Swift also has something called implicitly unwrapped optionals. These are optionals that do not need to be unwrapped using either forced unwrapping (!) or optional binding because they are unwrapped implicitly (automatically). They are declared using an exclamation mark (!) rather than a question mark (?). 
You often see implicitly unwrapped optionals when working with Interface Builder outlets (IBOutlet properties). For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
@IBOutlet weak var lblDescription: UILabel!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code, the lblDescription outlet property has an exclamation mark after it, indicating it is implicitly unwrapped. This allows you to access the property without unwrapping it.&lt;/p&gt;

&lt;p&gt;In this example, the outlet property isn&apos;t &lt;i&gt;guaranteed&lt;/i&gt; to contain a reference to a label but it absolutely &lt;i&gt;should&lt;/i&gt;. If it doesn&apos;t contain a reference to a label, it means that the connection between the outlet and the label has been broken. In that case, it&apos;s OK to have a run-time error because you want to know that the connection is broken so that you can fix it!&lt;/p&gt;
&lt;p&gt;Obviously, in cases where you&apos;re not 100 percent sure that a constant or variable contains a value you should use a regular optional instead.&lt;/p&gt;
&lt;a href=“https://www.iphonelife.com/blog/31369/swift-101-working-swifts-new-optional-values”&gt;Blog post&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What is the difference between line 1 and line 2 variables?&lt;/h2&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
// 1
@IBOutlet var lblFirst: UILabel!

// 2
@IBOutlet var lblSecond: UILabel?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>optional value</string>
			<key>Id</key>
			<string>42</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Line 1 has error</string>
				<string>Line 2 has error</string>
				<string>Line 3 has error</string>
				<string>Code has no errors and will be compiled</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Line 1 has error&lt;/h2&gt;
    &lt;p&gt;Initializer required because lblTopic is not an optional value&lt;/p&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class ScoreController: UIViewController {
	// 1 - Error - ’IBOutlet&apos; property has non-optional type &apos;UITextField&apos;
    @IBOutlet var lblTopic: UITextField
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Correct way is to use optional:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class ScoreController: UIViewController {
	// can be initialized later (manually in code) or automatically with Storyboard
   	@IBOutlet var lblTopic: UITextField? 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;…and then connect control to the outlet in XCode Storyboard.&lt;/p&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Do you see error here?&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
class ScoreController: UIViewController {
	// 1
   	@IBOutlet var lblTopic: UITextField

	// 2
   	@IBOutlet var lblLevel: UITextField!  

	// 3
	// Optional (iPad Storyboard only)
   	@IBOutlet var lblCorrect: UITextField?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>both lines with error</string>
			<key>Id</key>
			<string>41</string>
			<key>Tags</key>
			<string>Swift</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>1</string>
			<key>answers</key>
			<array>
				<string>Both lines (1 and 2) contain errors</string>
				<string>Line 1 has error</string>
				<string>Line 2 has error</string>
				<string>No errors here</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;Both lines contain errors&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
	func tst(){
        var strDesc: String = &quot;&quot;;
        let strPicture: String = &quot;Some_string&quot;;
        
        // 1 - Type &apos;Int&apos; does not conform to protocol &apos;BooleanType&apos;
        // != 0 required
		if(count(strPicture)){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }
        
        // 2 - Operand of postfix &apos;!&apos; should have optional type; type is &apos;Int&apos;
        // space required
		if(count(strPicture)!=0){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }

		…
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3&gt;Good tst function:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
	func tst(){
        var strDesc: String = &quot;&quot;;
        let strPicture: String = &quot;Some_string&quot;;
                
        if(count(strPicture) != 0){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }

		…
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What lines contain errors?&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
	func tst(){
        var strDesc: String = &quot;&quot;;
        let strPicture: String = &quot;Some_string&quot;;
        
        // 1
        if(count(strPicture)){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }
        
        // 2
        if(count(strPicture)!=0){
            strDesc = strDesc + &quot;\r\n&quot; + &quot;(got photo)&quot;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
		<dict>
			<key>Comment</key>
			<string>NS is nextstep </string>
			<key>Id</key>
			<string>40</string>
			<key>Tags</key>
			<string>Swift, IT History</string>
			<key>Level</key>
			<string>3</string>
			<key>Correct Answers</key>
			<string>2</string>
			<key>answers</key>
			<array>
				<string>NewStyle</string>
				<string>NextStep</string>
				<string>NumericSpec</string>
				<string>NumSpecified</string>
			</array>
			<key>a</key>
			<string>&lt;div&gt;
    &lt;h2&gt;NS stands for NeXTSTEP&lt;/h2&gt;
&lt;div&gt;
&lt;p&gt;&lt;b&gt;NeXTSTEP&lt;/b&gt; (also stylized as &lt;b&gt;NeXTstep&lt;/b&gt;, &lt;b&gt;NeXTStep&lt;/b&gt;, and &lt;b&gt;NEXTSTEP&lt;/b&gt;) is an object-oriented, multitasking operating system which was developed by NeXT Computer to run on its range of proprietary workstation computers, such as the NeXTcube. It was later ported to several other computer architectures.&lt;/p&gt;

&lt;p&gt;A preview release of NeXTSTEP (version 0.8) was shown with the launch of the NeXT Computer on October 12, 1988. The first full release, NeXTSTEP 1.0, shipped on September 18, 1989. The last version, 3.3, was released in early 1995, by which time it ran on not only the Motorola 68000 family processors used in NeXT computers, but also on Intel x86, Sun SPARC, and HP PA-RISC-based systems.&lt;/p&gt;

&lt;p&gt;Apple purchased NeXT in 1997 for $429 million and 1.5 million shares of Apple stock. As part of the agreement, Steve Jobs, Chairman and CEO of NeXT Software, returned to Apple, the company he had cofounded in 1976. The merger promised to marry software from NeXT with Apple&apos;s hardware platforms, eventually resulting in OS X and iOS. Parts of these operating systems incorporated the OPENSTEP foundation.&lt;/p&gt;

&lt;h3&gt;1987–93: NeXT Computer&lt;/h3&gt;
&lt;h4&gt;First generation&lt;/h4&gt;

&lt;p&gt;NeXT changed its business plan in mid-1986. The company decided to develop both computer hardware and software, instead of just a low-end workstation. A team led by Avie Tevanian, who had joined the company after working as one of the Mach kernel engineers at Carnegie Mellon University, was to develop the NeXTSTEP operating system. The hardware division, led by Rich Page, one of the cofounders who had previously led the Apple Lisa team, designed and developed the hardware. NeXT&apos;s first factory was completed in Fremont, California in 1987. It was capable of producing 150,000 machines per year. NeXT&apos;s first workstation was officially named the NeXT Computer, although it was widely referred to as &quot;the cube&quot; because of its distinctive case, a 1 ft magnesium cube, an edict of Jobs&apos; designed by Apple IIc case designer Frogdesign.&lt;/p&gt;

&lt;p&gt;The original design team had anticipated releasing the computer for US$ 3,000 in spring of 1987 to be ready for sale by summer of that year. Prototype workstations were eventually shown to standing ovations on October 12, 1988. The NeXT Computer was revealed at a lavish (invitation only) gala launch event &quot;NeXT Introduction - the Introduction to the NeXT Generation of Computers for Education&quot; at the Louise M. Davies Symphony Hall, San Francisco, California on Wednesday October 12 1988. The following day, selected educators and software developers were invited (for $100 registration fee) to attend the first public technical overview of the NeXT computer at an event called &quot;The NeXT Day&quot; held at the San Francisco Hilton. This event gave developers interested in developing NeXT software an insight into the software architecture, object-oriented programming and developing for the NeXT Computer. The luncheon speaker was Steve Jobs.&lt;/p&gt;

&lt;p&gt;The first machines were tested in 1989, after which NeXT started selling limited numbers to universities with a beta version of the NeXTSTEP operating system installed. Initially the NeXT Computer was targeted at US higher education establishments only, with a base price of $6,500. The machine was widely reviewed in magazines, generally concentrating on the hardware. When asked if he was upset that the computer&apos;s debut was delayed by several months, Jobs responded, &quot;Late? This computer is five years ahead of its time!”&lt;/p&gt;

&lt;p&gt;The NeXT Computer was based on the new 25 MHz Motorola 68030 central processing unit (CPU). The Motorola 88000 RISC chip was originally considered, but was not available in sufficient quantities. It included between 8 and 64 MB of random access memory (RAM), a 256 MB magneto-optical (MO) drive, a 40 MB (swap-only), 330 MB, or 660 MB hard drive, 10Base-2 Ethernet, NuBus and a 17-inch &lt;i&gt;MegaPixel&lt;/i&gt; grayscale display measuring 1120 by 832 pixels. In 1989 a typical new PC, Macintosh, or Amiga computer included a few MB of RAM, a 640×480 16-color or 320x240 4000-color display, a 10 to 20 megabyte hard drive and few networking capabilities. It also was the first computer to ship with a general-purpose DSP chip (Motorola 56001) on the mother board. This was used to support sophisticated music and sound processing, including the Music Kit software.&lt;/p&gt;

&lt;p&gt;The magneto-optical drive manufactured by Canon was used as the primary mass storage device. These drives were relatively new to the market, and the NeXT was the first computer to use them. They were cheaper than hard drives (blank media especially so: though each had a cost of $150 to Canon, Jobs&apos; typically forthright negotiations saw Canon agree to a retail of only $50 apiece) but slower (with an average seek time of 96 ms). The design made it impossible to move files between computers without a network, since each NeXT Computer had only one MO drive and the disk could not be removed without shutting down the system. Storage options proved challenging for the first NeXT Computers. The magneto-optical media was relatively expensive and had performance and reliability problems despite being faster than a floppy drive. The drive was not sufficient to run as the primary medium running the NeXTSTEP operating system both in terms of speed and capacity.&lt;/p&gt;

&lt;p&gt;In 1989, NeXT struck a deal for former Compaq reseller Businessland to sell NeXT computers in select markets nationwide. Selling through a retailer was a major change from NeXT&apos;s original business model of only selling directly to students and educational institutions. Businessland founder David Norman predicted that sales of the NeXT Computer would surpass sales of Compaq computers after 12 months.&lt;/p&gt;

&lt;p&gt;In 1989, Canon invested US$100 million in NeXT, giving it a 16.67 percent stake, making NeXT worth almost $600 million. Canon invested in NeXT with the condition that it would be able to use the NeXTSTEP environment with its own workstations, which would mean a greatly expanded market for the software. After NeXT exited the hardware business, Canon produced a line of PCs, called &lt;i&gt;object.station&lt;/i&gt;, including models 31, 41, 50 and 52, specifically designed to run NeXTSTEP/Intel. Canon also served as NeXT&apos;s distributor in Japan.&lt;/p&gt;

&lt;p&gt;The first NeXT computers were released on the retail market in 1990, for $9,999. NeXT&apos;s original investor Ross Perot resigned from the board of directors in June 1991 to dedicate more time to Perot Systems, a Plano, Texas-based systems integrator.&lt;/p&gt;

&lt;a href=&quot;http://en.wikipedia.org/wiki/NeXT&quot;&gt;Wiki&lt;/a&gt;</string>
			<key>q</key>
			<string>&lt;div&gt;
    &lt;h2&gt;What NS prefix in NSIndexPath stands for?&lt;/h2&gt;
&lt;div&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;
func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
	// toggle checkbox
    var cell:UITableViewCell = tableView.cellForRowAtIndexPath(indexPath)!
        
    if(cell.accessoryType == UITableViewCellAccessoryType.None){
    	cell.accessoryType = UITableViewCellAccessoryType.Checkmark
    }else{
    	cell.accessoryType = UITableViewCellAccessoryType.None
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</string>
		</dict>
	</array>
</dict>
</plist>
